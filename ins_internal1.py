# -*- coding: utf-8 -*-
"""INS Internal1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JUT4vkDfenguFvVIFjcgo982QH-dJRLS

# **Substitution Techniques**

**Caesar Cipher**
"""

def caesar_encrypt(text, key):
    return ''.join(chr((ord(c) - 65 + key) % 26 + 65) for c in text.upper())

def caesar_decrypt(cipher, key):
    return ''.join(chr((ord(c) - 65 - key) % 26 + 65) for c in cipher.upper())

# Example
msg = "HELLO"
key = 3
ct = caesar_encrypt(msg, key)
pt = caesar_decrypt(ct, key)

print("Cipher:", ct)  # KHOOR
print("Plain :", pt)  # HELLO

"""**Playfair Cipher**"""

import string

# --- build key matrix (5x5) ---
def generate_matrix(key):
    alphabet = "abcdefghiklmnopqrstuvwxyz"  # j merged with i
    key = key.replace("j", "i")  # simple handling
    matrix_str = ""
    for c in key + alphabet:
        if c not in matrix_str:
            matrix_str += c
    return [list(matrix_str[i:i+5]) for i in range(0, 25, 5)]

# --- find row, col of a letter ---
def find_pos(matrix, ch):
    for r in range(5):
        for c in range(5):
            if matrix[r][c] == ch:
                return r, c

# --- split into pairs ---
def make_pairs(text):
    text = text.replace("j", "i")  # unify j->i
    pairs, i = [], 0
    while i < len(text):
        a = text[i]
        b = text[i+1] if i+1 < len(text) else 'x'
        if a == b:
            pairs.append(a + 'x')
            i += 1
        else:
            pairs.append(a + b)
            i += 2
    return pairs

# --- encrypt ---
def playfair_encrypt(text, key):
    matrix = generate_matrix(key)
    pairs = make_pairs(text)
    ct = ""
    for a, b in pairs:
        ra, ca = find_pos(matrix, a)
        rb, cb = find_pos(matrix, b)
        if ra == rb:  # same row
            ct += matrix[ra][(ca+1)%5] + matrix[rb][(cb+1)%5]
        elif ca == cb:  # same col
            ct += matrix[(ra+1)%5][ca] + matrix[(rb+1)%5][cb]
        else:  # rectangle
            ct += matrix[ra][cb] + matrix[rb][ca]
    return ct

# --- decrypt ---
def playfair_decrypt(ct, key):
    matrix = generate_matrix(key)
    pt = ""
    for i in range(0, len(ct), 2):
        a, b = ct[i], ct[i+1]
        ra, ca = find_pos(matrix, a)
        rb, cb = find_pos(matrix, b)
        if ra == rb:
            pt += matrix[ra][(ca-1)%5] + matrix[rb][(cb-1)%5]
        elif ca == cb:
            pt += matrix[(ra-1)%5][ca] + matrix[(rb-1)%5][cb]
        else:
            pt += matrix[ra][cb] + matrix[rb][ca]
    return pt

# --- Example ---
msg = "hello"
key = "secret"

ct = playfair_encrypt(msg, key)
pt = playfair_decrypt(ct, key)

print("Key Matrix:")
for row in generate_matrix(key):
    print(row)
print("Message :", msg)
print("Cipher  :", ct)
print("Plain   :", pt)

"""**Hill Climbing**"""

import numpy as np
import string

alphabet = string.ascii_lowercase
char_to_num = {c: i for i, c in enumerate(alphabet)}
num_to_char = {i: c for i, c in enumerate(alphabet)}

# --- encryption ---
def hill_encrypt(msg, key):
    if len(msg) % 2 != 0:
        msg += 'x'
    nums = [char_to_num[c] for c in msg]
    nums = np.array(nums).reshape(-1, 2).T
    enc = key.dot(nums) % 26
    return ''.join(num_to_char[n] for n in enc.T.flatten())

# --- decryption ---
def hill_decrypt(ct, key):
    det = int(round(np.linalg.det(key))) % 26
    det_inv = pow(det, -1, 26)   # modular inverse
    adj = np.round(det * np.linalg.inv(key)).astype(int) % 26
    inv_key = (det_inv * adj) % 26
    nums = [char_to_num[c] for c in ct]
    nums = np.array(nums).reshape(-1, 2).T
    dec = inv_key.dot(nums) % 26
    return ''.join(num_to_char[n] for n in dec.T.flatten())

# --- Example ---
key = np.array([[3, 3], [2, 5]])  # must be invertible mod 26
msg = "hello"

ct = hill_encrypt(msg, key)
pt = hill_decrypt(ct, key)

print("Key matrix:\n", key)
print("Message   :", msg)
print("Cipher    :", ct)
print("Plain     :", pt)

"""# **Transposition Techniques**

**Rail Fence**
"""

def rail_encrypt(msg, rails):
    fence = [[] for _ in range(rails)]
    rail, step = 0, 1
    for c in msg:
        fence[rail].append(c)
        rail += step
        if rail == 0 or rail == rails-1:
            step *= -1
    return ''.join(''.join(row) for row in fence)

def rail_decrypt(ct, rails):
    # pattern of rail positions
    pattern, rail, step = [], 0, 1
    for _ in ct:
        pattern.append(rail)
        rail += step
        if rail == 0 or rail == rails-1:
            step *= -1

    # fill rails
    fence = [[] for _ in range(rails)]
    idx = 0
    for r in range(rails):
        for i, p in enumerate(pattern):
            if p == r:
                fence[r].append(ct[idx])
                idx += 1

    # read in zig-zag
    result, rail, step = "", 0, 1
    positions = [0]*rails
    for p in pattern:
        result += fence[p][positions[p]]
        positions[p] += 1
    return result

# --- Example ---
msg = "helloworld"
rails = 3

ct = rail_encrypt(msg, rails)
pt = rail_decrypt(ct, rails)

print("Message :", msg)
print("Cipher  :", ct)
print("Plain   :", pt)

"""**Row Transposition**"""

import math

def row_encrypt(msg, key):
    cols = len(key)
    rows = math.ceil(len(msg) / cols)

    # fill grid with padding 'x'
    grid = [['x']*cols for _ in range(rows)]
    idx = 0
    for r in range(rows):
        for c in range(cols):
            if idx < len(msg):
                grid[r][c] = msg[idx]
                idx += 1

    # read columns by key order
    ct = ""
    for k in sorted(range(cols), key=lambda i: key[i]):
        for r in range(rows):
            ct += grid[r][k]
    return ct

def row_decrypt(ct, key):
    cols = len(key)
    rows = math.ceil(len(ct) / cols)

    # prepare empty grid
    grid = [['']*cols for _ in range(rows)]
    idx = 0

    # fill columns in key order
    for k in sorted(range(cols), key=lambda i: key[i]):
        for r in range(rows):
            grid[r][k] = ct[idx]
            idx += 1

    # read row-wise
    pt = "".join("".join(row) for row in grid)
    return pt.rstrip('x')  # remove padding

# --- Example ---
msg = "helloworld"
key = [3,1,4,2]   # permutation of 1..n

ct = row_encrypt(msg, key)
pt = row_decrypt(ct, key)

print("Key      :", key)
print("Message  :", msg)
print("Cipher   :", ct)
print("Plain    :", pt)

"""**Columnar Transposition**"""

import math

def col_encrypt(msg, key):
    cols = len(key)
    rows = math.ceil(len(msg) / cols)

    # fill grid with padding 'x'
    grid = [['x']*cols for _ in range(rows)]
    idx = 0
    for c in range(cols):
        for r in range(rows):
            if idx < len(msg):
                grid[r][c] = msg[idx]
                idx += 1

    # read row-wise according to key order
    ct = ""
    for r in range(rows):
        for k in sorted(range(cols), key=lambda i: key[i]):
            ct += grid[r][k]
    return ct

def col_decrypt(ct, key):
    cols = len(key)
    rows = math.ceil(len(ct) / cols)

    # prepare empty grid
    grid = [['']*cols for _ in range(rows)]
    idx = 0

    # fill row-wise using key order
    for r in range(rows):
        for k in sorted(range(cols), key=lambda i: key[i]):
            grid[r][k] = ct[idx]
            idx += 1

    # read column-wise
    pt = ""
    for c in range(cols):
        for r in range(rows):
            pt += grid[r][c]
    return pt.rstrip('x')  # remove padding

# --- Example ---
msg = "helloworld"
key = [3,1,4,2]   # permutation of 1..n

ct = col_encrypt(msg, key)
pt = col_decrypt(ct, key)

print("Key      :", key)
print("Message  :", msg)
print("Cipher   :", ct)
print("Plain    :", pt)

!pip install pycryptodome

"""# **DES**"""

from Crypto.Cipher import DES
from Crypto.Random import get_random_bytes

# DES needs 8-byte key and IV
key = get_random_bytes(8)
iv = get_random_bytes(8)

cipher = DES.new(key, DES.MODE_CFB, iv)   # use CFB (no padding needed)
msg = b"Hello DES"
ct = cipher.encrypt(msg)

decipher = DES.new(key, DES.MODE_CFB, iv)
pt = decipher.decrypt(ct)

print("Cipher:", ct.hex())
print("Plain :", pt)

"""# **AES**"""

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

key = get_random_bytes(16)   # 16, 24, or 32 bytes
cipher = AES.new(key, AES.MODE_CFB)

msg = b"Hello AES"
ct = cipher.encrypt(msg)

decipher = AES.new(key, AES.MODE_CFB, cipher.iv)
pt = decipher.decrypt(ct)

print("Cipher:", ct.hex())
print("Plain :", pt)

"""# **RSA**"""

from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

# Generate keypair
key = RSA.generate(2048)
pub, priv = key.publickey(), key

# Encrypt with public key
msg = b"Hello RSA"
cipher = PKCS1_OAEP.new(pub)
ct = cipher.encrypt(msg)

# Decrypt with private key
decipher = PKCS1_OAEP.new(priv)
pt = decipher.decrypt(ct)

print("Cipher:", ct.hex())
print("Plain :", pt)